# Лекция 12
# VIII Аллокаторы
Это нужно, чтобы вызвать конструктор на определенную область памяти. И туда положить новый объект.
## Разновидности new
## 1) placement new

new (p) Type(params);

p - указатель на память.

p->~T(); - явный вызов деструктора по адресу;

## 2) Перегрузка оператора new. Самостоятельное выделение памяти
``` c++
static void* operator new(size_t n) {
    ...
}
```
Это для всех типов сразу.
Там внутри можно вызвать старый new через ``` ::operator new() ```

Оператор new сначала вызывает функцию operator new, потом вызывает конструктор на память, которая выделилась. Перегрузить можно только первую часть.

Так можно перегрузить placement-new
``` c++
static void* operator new(size_t n, void* p) {
    return p;
}
```


Delete p 

Сначала вызывает деструктор той штуки, потом освобождает память. Тут можно перегрузить только вторую штуку. 
Аналогично работает с  `new[]` и `delete[]`  

Рекомендуется писать delete с кастомными параметрами для каждного new  кастомными параметрами, чтобы компилятор мог в случае исключения сам освободить память.
## 3) Nothrow new

```c++
new(std::nothrow) T();
```
это не исключение выкинет, а вернет nullptr

`#include <new>` бибилиотека с оригинальными new
`#include <memory>` бибилиотека для аллокаторов

## 4) new_handler

 Перехватывает ошибку, если не хватило памяти

 set::set_new_handler()

 Если не хватило памяти, а new_handler не nullptr, он в бесконечном цикле будет вызывать new_handler пока не хватит памяти или функция не станет nullptr-ом.


## 5) `std::allocator<T>`

```c
template<class T>
struct std::allocator<T> {

T* allocate(size_t n)  const {
    return (T*)new char[n*size_of(T)];
}
    
void deallocate(T* p, size_t n) const  {
    delete[] p;
}

template<typename ... Args>
void construct(T* p, const Args&& ... args) const {
    return new(p) T(args...);
}

void destroy(T* p)  const {
    p->~T();
}

}
```

По сути это оболочка над `new` и `delete`
`construct` и `destory` можно не реализовывать, они всегда одинковые, так что их за вас реализуют (вызовут реализацию из allocator traits)

## 7) Пример нестандартного аллокатора

StackAllocator<typename T>

Выделяет сразу много памяти и по очереди заполняет память значениями. Освобождением памяти он не занимается. Это экономит время работы раза в 2, так как операционная система не думает, где выделить памяти.

